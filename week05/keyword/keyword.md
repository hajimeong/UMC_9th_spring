# Week 5 - 하지명
### 핵심 키워드
```text
- 지연로딩과 즉시로딩의 차이
- JPQL
- Fetch Join
- @EntityGraph
- commit과 flush 차이점
- QueryDSL, OpenFeign의 QueryDSL
- N+1 문제를 해결할 수 있는 여러 방안들
- 영속 상태의 종류
```
## 1) 지연로딩과 즉시로딩의 차이
즉시로딩과 지연로딩은 데이터베이스에서 데이터를 조회하는 방식 중 하나로,
객체 간의 연관관계를 어떻게 로딩하고 관리할 것인지에 대한 개념
### 1. 즉시로딩(Immediate Loading)
- 엔티티를 조회할 때 해당 엔티티와 연관된 모든 엔티티를 동시에 조회하는 방식
- A 엔티티와 B 엔티티가 연관되어 있을 때 A를 조회하면 B도 함께 조회됨 </br> -> 객체 간의 관계를 필요한 시점에 바로 사용할 수 있음
- 조인 등의 복잡한 쿼리가 생성될 수 있고, 불필요한 데이터 로딩으로 인해 성능 문제가 발생할 수 있음
#### 즉시 로딩을 선택하는 이유
1. **객체 간의 관계를 활용하기 편리**
   - 즉시로딩을 사용하면 객체를 조회할 때 연관된 모든 객체가 한 번에 로딩되므로 객체 간의 관계를 편리하게 활용할 수 있음
   - 모든 연관된 데이터가 이미 로딩되어 있으므로 어떤 객체를 사용할 때 별 다른 데이터베이스 조회 없이 객체 그래프를 따라 이동할 수 있음
2. **복잡한 조회를 단순화**
   - 데이터베이스에서 조인을 사용하여 복잡한 연관관계를 해결할 필요 없이, 즉시로딩으로 모든 데이터를 한 번에 가져올 수 있음

### 2. 지연로딩(Lazy Loading)
- 객체를 Proxy로 가져온 후 실제 해당 객체를 사용하는 시점에 초기화
- 지연로딩은 연관된 엔티티를 처음에는 조회하지 않고, 실제로 해당 엔티티가 필요한 시점에 조회하는 방식
- A 엔티티를 조회해도 B 엔티티는 초기에 조회되지 않고, B 엔티티를 실제로 사용할 때 데이터베이스에서 조회됨 </br> -> 쿼리의 최적화와 성능 향상을 이룰 수 있음
- 연관 엔티티를 사용하는 과정에서 데이터베이스 쿼리가 추가적으로 발생할 수 있음
#### 지연로딩을 선택하는 이유
1. **성능 최적화**
    - 즉시로딩은 모든 연관된 데이터를 한 번에 가져오기 때문에, 필요하지 않은 데이터까지 불필요하게 로딩될 수 있음
    - 지연로딩은 필요한 시점에만 데이터를 로딩하기 때문에 성능을 최적화할 수 있음
2. **데이터 접근 최적화**
    - 사용자가 실제로 해당 데이터를 사용할 때만 로딩하므로, 데이터베이스 접근이 최적화됨
    - 시스템 전체적으로 데이터 로딩에 대한 부하가 분산될 수 있음
3. **순환 참조 방식**
    - 지연로딩을 사용하면 객체 간의 연관관계에서 순환 참조가 발생할 확률이 줄어듦
    - 객체를 조회할 때 실제로 필요한 데이터만 로딩되므로 무한한 순환 참조를 방지할 수 있음
4. **메모리 사용 최적화**
   - 즉시로딩은 연관된 모든 데이터를 로딩하기 때문에 메모리를 많이 사용할 수 있음
   - 지연로딩은 필요한 데이터만 로딩하기 때문에 메모리 사용량을 최적화할 수 있음

## 2) JPQL
- SQL을 기반으로 한 객체 모델용 쿼리 언어로 SQL과 매우 유사한 형태지만, 데이터베이스 '테이블과 컬럼'이 아닌 '자바 클래스와 변수(객체)'에 작업을 수행한다는 점에 차이가 존재
- 데이터베이스 테이블을 대상으로 쿼리하는 것이 아닌 엔티티(객체)를 대상으로 쿼리를 수행함

### JPQL 특징
|특징|설명|
|:---|:---|
|기본적인 연산 지원|SELECT, UPDATE, DELETE, INSERT(Embeddable 클래스 한정) 등의 기본적인 연산을 지원하며, 함수, 연산자, 키워드 등 다양한 기능을 제공|
|객체지향 쿼리 언어|자바의 특성을 최대한 활용할 수 있으며, 쿼리 결과를 객체 또는 객체의 컬렉션으로 직접 반환받을 수 있음|
|타입 안정성 제공|컴파일 시점에 쿼리의 문법 오류를 검사할 수 있음|

### JpaRepository와의 차이점
|   분류   | JpaRepository                                                                       | JPQL                                                           |
|:------:|:------------------------------------------------------------------------------------|:---------------------------------------------------------------|
|   정의   | Spring Data JPA에서 제공하는 인터페이스로 개발자가 JPA를 더 쉽고 편하게 사용할 수 있게 도와줌                       | Java Persistence Query Language의 약자로, SQL을 기반으로 한 객체 모델용 쿼리 언어 |
| 사용 용이성 | JpaRepository를 상속받은 Repository 인터페이스를 생성함으로써 간단하게 CRUD 기능을 사용할 수 있음                 | SQL과 비슷한 문법을 가지며, 객체 지향적인 쿼리를 작성할 수 있음                         |
|  유연성   | Spring Data JPA에 의해 구현되므로, 개발자는 쿼리를 직접 작성하지 않아도 됨. 하지만 이는 복잡한 쿼리를 작성하는데 한계가 있을 수 있음 | SQL과 비슷한 문법을 가지며, 객체 지향적인 쿼리를 작성할 수 있음                         |
|호환성|JpaRepository는 JPA를 기반으로 하므로 JPA를 지원하는 모든 데이터베이스 시스템과 호환됨|JPQL도 JPA를 기반으로 하므로, JPA를 지원하는 모든 데이터베이스 시스템과 호환됨|

### JPQL 처리방식
1. 리턴 타입 '쿼리 타입'을 지정: TypedQuery, Query
2. 쿼리를 구성함: createQuery
3. 쿼리 프로젝션을 설정함: 엔티티, 임베디드 타입, 스칼라 타입 프로젝션
4. 쿼리 파라미터를 지정함: 이름 기준, 위치 기준
5. 쿼리 결과를 조회 방식을 선택: getSingleResult(), getResultList()

#### JPQL 쿼리 방식
JPQL에서 쿼리를 만드는 방식에는 TypedQuery 클래스를 이용하는 방식과 Query 클래스를 이용하는 방식 2가지 존재
1. TypedQuery
   - 반환되는 `타입이 명확할 때` 사용하는 클래스
   - 반환 타입을 미리 지정하기 때문에, 컴파일 시점에 오류를 잡을 수 있어 안정적
2. Query
   - 반환되는 `타입이 명확하지 않을 때` 사용하는 클래스
   - 다양한 타입의 결과로 반환받을 수 있지만, 타입 체크가 런타임 시점에 수행되어 안정성이 떨어질 수 있음

#### JPQL 파라미터 방식
JPQL 쿼리를 처리할 때 파라미터에 따라 동적으로 처리하는 방식
1. 이름 기준 파라미터 바인딩
   - 쿼리 내에서 `:변수명` 형태로 선언한 후에 setParameter 메서드를 사용하여 값을 설정하는 방식
2. 위치 기준 파라미터 바인딩
   - 쿼리 내에 파라미터를 `?위치번호` 형태로 선언한 후 setParameter 메서드를 사용해 값을 설정
   - 권장하지 않음. 복잡한 쿼리문의 같은 경우 위치값이 변할 수 있기 때문에 직접적인 매핑이 되는 이름 기준으로 파라미터 바인딩을 권장

## 3) Fetch Join
페치 조인은 SQL에서 이야기하는 조인의 종류가 아니라, JPQL에서 성능 최적화를 위해 제공하는 조인의 종류임</br>
연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있는 기능으로 `JOIN FETCH` 명령어로 사용 가능

### Fetch Join의 특징
|구분|설명|
|:---|:---|
|목적|지연 로딩으로 인한 N+1 문제 해결|
|쿼리 형태|`join fetch` 키워드를 사용(JPQL 전용 문법)|
|결과|연관된 엔티티까지 한 번에 가져옴|
|주의점|페이징(`setFirstResuilt`, `setMaxResuilt`)과 함께 사용 시 주의 필요(일대다 조인 시 데이터 중복 가능)|


### Fetch Join 예시
#### 1. 일반 조인
```java
select m from Member m join m.team t
```
- 단순히 member와 team을 조인 조건으로 묶어서 필터리
- 실제로 team 엔티티는 로딩되지 않음(지연 로딩 그대로 유지)
#### 2. Fetch Join
```java
select m from Memmber m join fetch m.team
```
- member를 조회하면서 team 엔티티까지 즉시 로딩
- 영속성 컨텍스트에 Team도 함께 저장됨

## 4) @EntityGraph
연관관계가 있는 엔티티를 조회할 경우 
지연 로딩으로 설정되어 있으면 연관관계에서 종속된 엔티티는 쿼리 실행 시 select 되지 않고 proxy 객체를 만들어 엔티티를 적용시킴
</br>
그 후 해당 proxy 객체를 호출할 때마다 그때그때 select 쿼리가 실행됨</br>
연관관계가 지연 로딩으로 되어있을 경우, fetch 조인을 상요해 여러 번의 쿼리를 한 번에 해결 가능</br>
@EntityGraph는 Data JPA에서 fetch join을 어노테이션으로 사용할 수 있도록 만들어준 기능

## 5) commit과 flush의 차이점
### 1. flush()
flush()는 영속성 컨텍스트의 변경사항을 즉시 데이터베이스에 반영(동기화)하는 역할</br>
데이터베이스와 영속성 컨텍스트 사이의 스냅샷을 일치시키는 작업</br>
- 스냅샷: 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는 것 </br>

에러 발생 시, ROLLBACK이 가능한 단계까지만 반영하는 작업임을 알 수 있음</br>
그리고 flush()가 호출되면 변경된 엔티티가 SQL로 변환되어 실행되지만, 트랜잭션이 끝난 것은 아님
#### flush() 언제 사용할까?
- 변경 사항을 즉시 데이터베이스에 반영해야 하지만, 트랜잭션은 유지해야 할 때 사용(대량 데이터 처리)
- JPQL 실행 전에 변경 사항을 강제 반영해야 할 때 사용

### 2. commit()
commit()은 현재 트랜잭션을 완료하고, 모든 변경 사항을 확정하는 역할 </br>
내부적으로 flush()를 수행한 후, 실제로 트랜잭션을 커밋 </br>
commit()이 실행되면 변경 사항이 영구적으로 저장되며 ROLLBACK할 수 없음
#### commit() 언제 사용할까?
- 데이터베이스 변경 사항을 최종적으로 확정할 때 사용
- 하나의 작업 단위를 끝내고 안정적인 저장이 필요할 때 사용

### 결론
|         구분         |        flush()        |      commit()       |
|:------------------:|:---------------------:|:-------------------:|
|       실행 시점        |   즉시 데이터베이스에 SQL 실행   |     트랜잭션 종료 시점      |
|     트랜잭션 종료 여부     |       트랜잭션 유지됨        |      트랜잭션 종료됨       |
|      롤백 가능 여부      |          가능           |   불가능(커밋되면 롤백 불가)   |
| 내부적으로 flush()호출 여부 |      명시적으로 호출 필요      |    내부적으로 자동 호출됨     |
|       주요 목적        | 변경 사항을 즉시 반영(트랜잭션 유지) | 변경 사항을 확정하고 트랜잭션 종료 |


## 6) QueryDSL, OpenFeign의 QueryDSL
### QueryDSL
하이버네이트 쿼리 언어(HQL: Hibernate Query Language)의 쿼리를 타입에 안전하게 생성 및 관리해주는 프레임워크</br>
QueryDSL은 정적 타입을 이용해 SQL과 같은 쿼리를 생성할 수 있게 해줌</br>

자바 백엔드 기술은 Spring Boot와 Spring Data JPA를 함께 사용하지만, 복잡한 쿼리, 동적 쿼리를 구현하는 데에 있어 한계가 있음</br>
### QueryDSL을 사용하는 이유
1. 자바 코드로 쿼리를 작성함으로 컴파일 시점에 에러를 잡을 수 있음
2. 복잡한 동적 쿼리를 쉽게 다룰 수 있음

### QueryDSL의 장점
- 문자가 아닌 코드로 쿼리를 작성할 수 있어 컴파일 시점에 문법 오류를 확인할 수 있음
- 인테리제이와 같은 IDE의 자동 완성 기능의 도움을 받을 수 있음
- 복잡한 쿼리나 동적 쿼리 작성이 편리함
- 쿼리 작성 시 제약 조건 등을 메서드 추출을 통해 재사용할 수 있음
- JPQL 문법과 유사한 형태로 작성할 수 있어 쉽게 적용 가능

#### JPQL과 QueryDSL 비교
1. JPQL
    ```java
    String username="java";
    String jpql="select m from Member m where m.username=:username";
    
    List<Member> result=em.createQuery(query, Member.class).getResultList();
    `````
2. QueryDSL
    ```java
    String username="java";
    
    List<Member> result=queryFactory
            .select(member)
            .from(member)
            .where(usernameEq(username))
            .fetch();
    ```

## 7) N+1 문제를 해결할 수 있는 여러 방안들
### 1. Fetch Join
JPQL을 사용하여 DB에서 데이터를 가져올 때 처음부터 연관된 데이터까지 같이 가져오게 하는 방법</br>
별도의 메소드를 만들어줘야 하면 @Query 어노테이션을 사용해서 "join fetch 엔티티.연관관계_엔티티" 구문을 만들어주면 됨
```java
public interface TeamRepository extends JpaRepository<Team, Long>{
    @Query("select t from Team t join fetch t.users")
    List<Team> findAllFetchJoin();
}
```
SQL 로그를 보면 별도의 지정을 안하면 JPQL에서 join fetch 구문은 SQL문의 inner join 구문으로 변경되어 실행

### 2. EntityGraph 어노테이션
@EntityGraph라는 어노테이션을 사용해서 fetch 조인을 하는 것</br>
사용하는 순간 조금만 관계가 복잡해져도 어려워짐. 이런 게 있구나만 알자

### 3. Batch Size
이 옵션은 정확히는 N+1 문제를 안 일어나게 하는 방법은 아니지만, </br>
N+1 문제가 발생하더라도 select * from user where team_id=?이 아닌
`select * from user where team_id in (?,?,?)` 방식으로 N+1 문제가 발생하게 하는 방법 </br>
이렇게 하면 100번 일어날 N+1 문제를 1번만 더 조회하는 방식으로 성능을 최적화할 수 있음</br>

**application.yml**
```yml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size:1000
```

**application.properties**
```properties
spring.jpa.properties.hibernate.default_batch_fetch_size=1000
```
#### 실무에서 N+1문제로 DB가 죽어버리는 문제를 방지하기 위해서는?
연관관계에 대한 설정이 필요하다면 FetchType을 성능 최적화를 하기 어려운 즉시로딩을 사용하는 게 아니라
지연 로딩 모드로 사용하고 성능 최적화가 필요한 부분에는 Fetch 조인을 사용함</br>
또한, 기본적으로 Batch Size의 값을 1000이하로 설정 (대부분의 DB에서 IN절의 최대 개수 값:1000) </br>

N+1문제로 인해 DB가 죽어버리는 불상사를 막기 위해 연관과계를 끊어버리고 사용하는 것도 방법임

## 8) 영속 상태의 종류
### 1. 비영속(New/Transient)
비영속 상태는 **순수한 객체 상태**를 의미함</br>
`new Member()` 처럼 객체를 생성했지만, 아직 JPA의 영속성 컨텍스트에 저장하지 않은 상태임 </br>
따라서 이 객체는 영속성 컨텍스트나 데이터베이스와는 아무런 관련이 없음</br> 그저 메모리게 평범한 객체일 뿐
```java
//Member 객체를 생성
//이 member 객체는 현재 '비영속' 상태
val member=Member(id=1L, name="newbie");
```

### 2. 영속 (Managed)
영속 상태는 **엔티티가 영속성 컨텍스트에 의해 관리되는 상태**를 의미</br>
`EntityManager.persist()`를 호출해 비영속 상태의 엔티티를 영속성 컨텍스트에 저장하거나,</br>
`EntityManager.find()`를 통해 데이터베이스에서 엔티티를 조회하면 해당 엔티티는 영속 상태가 됨</br>

영속 상태가 된 엔티티는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 등 JPA가 제공하는 모든 기능의 혜택을 받음.
우리가 JPA의 마법이라고 부르는 현상들은 모두 엔티티가 바로 이 영속 상태에 있을 때 일어남</br>
```java
// 비영속 상태의 member 객체를 생성
val member = Member(id = 1L, name = "managedUser");

// EntityManager를 통해 member를 영속성 컨텍스트에 저장한다.
// 이 순간부터 member는 '영속' 상태가 된다.
entityManager.persist(member) ;

// DB에서 ID가 2L인 회원을 조회한다.
// 조회된 foundMember 역시 '영속' 상태다.
val foundMember = entityManager.find(Member::class.java, 2L);

```

### 3. 준영속(Detached)
준영속 상태는 **엔티티가 과거에는 영속 상태였지만, 더 이상 영속성 컨텍스트가 관리하지 않은 상태**를 의미</br>
영속성 컨텍스트가 제공하는 어떤 기능도 동작하지 않음</br>

#### 엔티티가 준영속 상태가 되는 경우
1. `entityManager.detach(entity)`: 특정 엔티티 하나만 골라 준영속 상태로 만듦
2. `entityManager.clear()`: 영속성 컨텍스트를 통째로 비워 모든 엔티티를 준영속 상태로 만듦
3. `entityManager.close()`: 영속성 컨텍스트를 종료하여 모든 엔티티를 준영속 상태로 만듦(주로 트랜잭션이 끝날 때 발생)
```java
// member는 현재 영속 상태
val member = entityManager.find(Member::class.java, 1L) ;

// member를 영속성 컨텍스트에서 분리한다.
// 이제 member는 '준영속' 상태가 된다.
entityManager.detach(member);

// 준영속 상태이므로, 이름을 바꿔도 UPDATE 쿼리가 실행되지 않는다.
member.name = "detachedUser" ;
```
준영속 상태의 엔티티는 더 이상 JPA의 관리를 받지 않으므로, 값을 변경해도 변경 감지가 일어나지 않아 데이터베이스에 반영되지 않음

### 4. 삭제(Removed)
삭제 상태는 **엔티티를 데이터베이스에서 삭제하기로 결정한 상태**</br>
영속성 컨텍스트에 있는 영속 상태의 엔티티에 대해 `EntityManager.remove()`를 호출하면 해당 엔티티는 삭제 상태가 됨</br>

삭제 상태가 된 엔티티는 여전히 영속성 컨텍스트의 관리를 받지만, 트랜잭션이 커밋되는 시점에 데이터베이스에 DELETE SQL이 전달되고,
영속성 컨텍스트에서도 제거됨
```java
// member는 현재 영속 상태
val member = entityManager.find(Member::class.java, 1L);

// member를 삭제 상태로 만든다.
// 트랜잭션이 커밋될 때 실제 DELETE 쿼리가 나간다.
entityManager.remove(member);
```